Tags : 



**Problem Link**: https://leetcode.com/problems/top-k-frequent-elements/ 
**Category**: #arrays #DSA
**Difficulty**: #medium 
**Topics**: [[arrays]] , [[bucket sort]] , [[hashmap]]

---

## Approach

- 0(n) solution -> Use bucket sort algorithm.  
  
- steps for algorithm :

	1. Count the freq of each number in a HashMap
	
	2. Create bucket arrays ( index = freq )
	
	3. Traverse the bucket arrays from high to low and return the top K elements.
	   
- Ex : Buckets are stored as below , 
	
![[Pasted image 20250517222402.png]]


---

## Code (Java)

```java
public int[] topKFrequent(int[] nums, int k) {

	Map<Integer,Integer> hm = new HashMap<>();
	
	  
	
	// 1. count freq
	
	for(int num : nums) hm.put(num , hm.getOrDefault(num,0)+1);
	
	  
	
	// 2. create bucket arrays size of nums
	
	List<Integer>[] buckets = new List[nums.length+1];
	
	for(int i = 0 ; i<buckets.length;i++) buckets[i] = new ArrayList<>();
	
	  
	
	for(Map.Entry<Integer,Integer> entry : hm.entrySet())
	
	{
	
		int num = entry.getKey();
		
		int freq = entry.getValue();
		
		buckets[freq].add(num);
	
	}
	
	  
	
	// 3. Loop from high to low and return top k elements
	
	int[] res = new int[k];
	
	int index = 0;
	
	  
	
	for(int i = buckets.length-1 ; i>=0 && index<k ; i--)
	
	{
	
		for(int num : buckets[i])
	
		{
		
			res[index++] = num;
			
			if(index == k) break;
		
		}
	
	}
	
	  
	
	return res;
	
}

```


