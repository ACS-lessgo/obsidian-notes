
**Problem Link**: {{link}}  
**Category**: #binary-search  
**Difficulty**: #medium  
**Topics**: [[binary search]]

---

## Approach

- initially consider the eating rate as the max element of the array.
- lower bound = 1 (lowest eating rate) and upper bound = highest eating rate.
- we can calculate the time to eat by --> time = pile / k (eating rate) and we check every time if time <= h we decrease max rate , else increase min rate
- 1 4 3 2 with eating rate of 4 time = 4
- 1 4 3 2 with eating rate of 3 time = 5
- 1 4 3 2 with eating rate of 2 time = 6 we got the least rate to eat
- 1 4 3 2 with eating rate of 1 time = 10 (10>h) not possible

---

## Code (Java)

```java
public int minEatingSpeed(int[] piles, int h) {

	int l=1;	
	int r = Arrays.stream(piles).max().getAsInt();
	int res = r;

	while(l<=r)
	{	
		int k = (l+r)/2;		
		long time = 0;
		
		for(int pile : piles)
		{
			time += Math.ceil((double)pile/k);
		}
		
		if(time<=h)
		{
			res = k;	
			r = k-1;
		}else{
			l = k+1;
		}
	}
	
	return res;
}

```


## References :