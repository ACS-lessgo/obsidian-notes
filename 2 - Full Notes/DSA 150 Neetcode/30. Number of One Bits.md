
**Problem Link**: https://leetcode.com/problems/number-of-1-bits/ 
**Category**: #bitwise-operators
**Difficulty**: #easy  
**Topics**: [[bit manipulation]]

---

## Approach

- Right shift : Each right shift by 1 divides the number by 2 (ignoring remainder)
  
	  8 >> 1 = 4
	  4 >> 1 = 2
	  2 >> 1 = 1
	  1 >> 1 = 0
#### Approach 1 :
![[Pasted image 20250524155844.png]]

- we can add 0001 to our given number , check if the last digit is 1 , and do a right shift

#### Approach 2:

- Each time you do `n = n & (n - 1)`, it **removes the lowest set bit** (i.e., the rightmost `1`) from `n`. [Brian Kernighanâ€™s Algorithm]

---

## Code (Java)

```java
public int hammingWeight(int n) {
	int res = 0;
	
	while(n!=0)	
	{	
		n&=n-1;		
		res++;	
	}	
	return res;
}

```


```java
public int hammingWeight(int n) {
	int res = 0;
	
	while(n!=0)	
	{	
		res+=n%2;		
		n>==1;	
	}	
	return res;
}
```
## References :

- https://youtu.be/5Km3utixwZs?si=mC4RFHwk4ypmGlxx